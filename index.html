<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Dream Machine v1.0</title>
    <style>
      body {
        margin: 0;
        background: black;
        color: white;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        text-align: center;
      }
      #start-screen {
        padding: 2rem;
      }
      #controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: center;
        margin: 1rem 0;
      }
      button,
      input[type="file"] {
        background: #222;
        color: white;
        border: 1px solid #444;
        padding: 0.5rem 1rem;
        cursor: pointer;
      }
      canvas {
        max-width: 90vw;
        max-height: 80vh;
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <div id="start-screen">
      <h1>Dream Machine v1.0</h1>
      <p>
        A browser-based generative system that gradually mutates a user-supplied
        image using autonomous agents.<br />
        The image shifts from within—through drift, color shifts, and pixel
        zoom—evoking a slow, machine-driven dream state.<br /><br />This is an
        ongoing project by artist Niklas Wallenborg, exploring machine-human
        creativity through post-digital aesthetics.
      </p>
      <input type="file" id="upload" accept="image/*" />
    </div>

    <canvas id="canvas" style="display: none"></canvas>
    <div id="controls" style="display: none">
      <button id="toggle">Stop</button>
      <button id="reset">Upload New Image</button>
      <button id="save">Save Image</button>
    </div>

    <script>
      const upload = document.getElementById("upload");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const controls = document.getElementById("controls");
      const toggleBtn = document.getElementById("toggle");
      const resetBtn = document.getElementById("reset");
      const saveBtn = document.getElementById("save");
      const startScreen = document.getElementById("start-screen");

      let imageLoaded = false;
      let paused = false;
      let animationFrame;
      const agents = [];

      upload.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const img = new Image();
        img.onload = () => {
          const maxWidth = 1280;
          if (img.width > maxWidth) {
            const scale = maxWidth / img.width;
            canvas.width = maxWidth;
            canvas.height = img.height * scale;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          } else {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
          }
          imageLoaded = true;
          startScreen.style.display = "none";
          canvas.style.display = "block";
          controls.style.display = "flex";
          animate();
        };
        img.src = URL.createObjectURL(file);
      });

      function createAgent() {
        const agent = {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          angle: Math.random() * Math.PI * 2,
          speed: Math.random() * 1.2 + 0.4,
          age: 0,
          lifeSpan: Math.floor(Math.random() * 600 + 300),
          moodTimer: 0,
          nextMoodChange: Math.floor(Math.random() * 200 + 100),
        };
        randomizeMood(agent);
        return agent;
      }

      function randomizeMood(agent) {
        agent.driftX = Math.floor(Math.random() * 9 - 4);
        agent.driftY = Math.floor(Math.random() * 9 - 4);
        agent.formSize = Math.floor(Math.random() * 80 + 10);
        agent.formCompactness = Math.random();
        agent.doColor = Math.random() < 0.8;
        agent.doDrift = Math.random() < 0.6;
        agent.doPixelZoom = Math.random() < 0.1;
        agent.nextMoodChange = Math.floor(Math.random() * 200 + 100);
      }

      function generateMask(x, y, cellSize, steps, compactness = 1) {
        const gx = Math.floor(x / cellSize);
        const gy = Math.floor(y / cellSize);
        const visited = new Set();
        const queue = [[gx, gy]];
        visited.add(`${gx},${gy}`);
        const shape = [];

        while (shape.length < steps && queue.length > 0) {
          const [cx, cy] = queue.shift();
          const px = cx * cellSize;
          const py = cy * cellSize;

          if (
            px < 0 ||
            py < 0 ||
            px + cellSize > canvas.width ||
            py + cellSize > canvas.height
          )
            continue;

          shape.push({ x: px, y: py, w: cellSize, h: cellSize });

          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ].sort(() => Math.random() - 0.5);
          for (const [dx, dy] of dirs) {
            if (Math.random() < compactness) {
              const nx = cx + dx;
              const ny = cy + dy;
              const key = `${nx},${ny}`;
              if (!visited.has(key)) {
                visited.add(key);
                queue.push([nx, ny]);
              }
            }
          }
        }

        return shape;
      }

      function applyMorph(agent, imgData) {
        const data = imgData.data;
        const original = new Uint8ClampedArray(data);
        const cellSize = 10;
        const shape = generateMask(
          agent.x,
          agent.y,
          cellSize,
          agent.formSize,
          agent.formCompactness
        );

        let zoomR = 0,
          zoomG = 0,
          zoomB = 0,
          zoomA = 255;
        if (agent.doPixelZoom && shape.length > 0) {
          const center = shape[Math.floor(Math.random() * shape.length)];
          const cx = center.x;
          const cy = center.y;
          const i = (cy * canvas.width + cx) * 4;
          zoomR = original[i];
          zoomG = original[i + 1];
          zoomB = original[i + 2];
          zoomA = original[i + 3];
        }

        shape.forEach(({ x, y, w, h }) => {
          for (let dy = 0; dy < h; dy++) {
            for (let dx = 0; dx < w; dx++) {
              const sx = x + dx;
              const sy = y + dy;
              const tx = sx + agent.driftX;
              const ty = sy + agent.driftY;

              if (sx < 0 || sy < 0 || sx >= canvas.width || sy >= canvas.height)
                continue;

              const i = (sy * canvas.width + sx) * 4;
              let r = original[i];
              let g = original[i + 1];
              let b = original[i + 2];
              let a = original[i + 3];

              if (agent.doPixelZoom) {
                r = zoomR;
                g = zoomG;
                b = zoomB;
                a = zoomA;
              }

              if (agent.doColor) {
                const shift = Math.random() * 18 - 9;
                r = Math.min(255, Math.max(0, r + shift));
                g = Math.min(255, Math.max(0, g + shift));
                b = Math.min(255, Math.max(0, b + shift));
              }

              if (
                agent.doDrift &&
                tx >= 0 &&
                ty >= 0 &&
                tx < canvas.width &&
                ty < canvas.height
              ) {
                const ti = (ty * canvas.width + tx) * 4;
                r = original[ti];
                g = original[ti + 1];
                b = original[ti + 2];
                a = original[ti + 3];
              }

              data[i] = r;
              data[i + 1] = g;
              data[i + 2] = b;
              data[i + 3] = a;
            }
          }
        });
      }

      function animate() {
        if (!imageLoaded || paused) return;

        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        if (Math.random() < 0.02 || agents.length < 1) {
          agents.push(createAgent());
        }

        for (let i = agents.length - 1; i >= 0; i--) {
          const agent = agents[i];
          agent.age++;
          agent.moodTimer++;

          if (agent.moodTimer > agent.nextMoodChange) {
            randomizeMood(agent);
            agent.moodTimer = 0;
          }

          applyMorph(agent, imgData);

          if (Math.random() < 0.2) {
            agent.angle += (Math.random() - 0.5) * 0.3;
          }
          if (Math.random() < 0.005) {
            agent.angle = Math.random() * Math.PI * 2;
          }

          agent.x += Math.cos(agent.angle) * agent.speed;
          agent.y += Math.sin(agent.angle) * agent.speed;

          if (agent.x < 0 || agent.x > canvas.width)
            agent.angle = Math.PI - agent.angle;
          if (agent.y < 0 || agent.y > canvas.height)
            agent.angle = -agent.angle;

          if (agent.age > agent.lifeSpan && agents.length > 1) {
            agents.splice(i, 1);
          }
        }

        ctx.putImageData(imgData, 0, 0);
        animationFrame = requestAnimationFrame(animate);
      }

      toggleBtn.addEventListener("click", () => {
        paused = !paused;
        toggleBtn.textContent = paused ? "Resume" : "Stop";
        if (!paused) animate();
      });

      resetBtn.addEventListener("click", () => {
        window.location.reload();
      });

      saveBtn.addEventListener("click", () => {
        const link = document.createElement("a");
        link.download = "dream-machine.png";
        link.href = canvas.toDataURL();
        link.click();
      });
    </script>
  </body>
</html>
